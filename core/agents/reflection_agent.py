"""
Agente reflexivo que analisa padr√µes e atualiza a identidade simb√≥lica do sistema.
VERS√ÉO ATUALIZADA: Remove depend√™ncia do analysis_history.md em favor do GraphRAG
"""

import os
from datetime import datetime
from memory.graph_rag.graph_interface import GraphMemory, MockGraphMemory
from neo4j import exceptions

# Importar configura√ß√µes de legacy features
try:
    from config.settings import LEGACY_FEATURES
except ImportError:
    # Fallback se settings n√£o estiver dispon√≠vel
    LEGACY_FEATURES = {
        "enable_analysis_history_md": False,
        "verbose_logging": False
    }


class ReflectionAgent:
    def __init__(self):
        # Configurar GraphRAG (principal sistema de armazenamento)
        try:
            self.graph = GraphMemory()
            # Testa a conex√£o
            self.graph.get_categories_and_counts()
            self.using_mock = False
            print("üîó GraphRAG conectado com sucesso")
        except (exceptions.ServiceUnavailable, exceptions.AuthError) as e:
            from memory.graph_rag.graph_interface import MockGraphMemory
            self.graph = MockGraphMemory()
            self.using_mock = True
            print(f"‚ö†Ô∏è Neo4j n√£o dispon√≠vel ({str(e)}) - usando implementa√ß√£o em mem√≥ria")
        
        # ‚ö° OTIMIZA√á√ÉO: Configurar path do log apenas se habilitado
        self.enable_md_logging = LEGACY_FEATURES.get("enable_analysis_history_md", False)
        if self.enable_md_logging:
            self.log_path = os.path.join("reflection", "analysis_history.md")
            print("üìù Log MD habilitado (modo compatibilidade)")
        else:
            self.log_path = None
            print("üöÄ Log MD desabilitado - usando apenas GraphRAG")
        
        # Estat√≠sticas de reflex√£o
        self.reflection_stats = {
            "total_cycles": 0,
            "patterns_identified": {},
            "agents_processed": set()
        }

    def reflect_on_tasks(self, agents):
        """
        Reflex√£o principal - OTIMIZADA para usar principalmente GraphRAG
        """
        print("üîÅ Iniciando reflex√£o simb√≥lica sobre os agentes...\n")
        
        # Registrar estat√≠sticas
        self.reflection_stats["total_cycles"] += 1
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # ‚ö° OTIMIZA√á√ÉO: Preparar dados apenas se logging MD estiver habilitado
        log_lines = []
        if self.enable_md_logging:
            log_lines.append(f"### Ciclo de Reflex√£o ‚Äî {timestamp}\n")

        # Processar cada agente
        processed_patterns = []
        for agent in agents:
            try:
                # Extrair informa√ß√µes do agente
                reaction = getattr(agent, 'latest_output', '') or ''
                pattern = self.identify_pattern(reaction)
                category = self.categorize_pattern(pattern)
                agent_name = agent.__class__.__name__
                
                # Registrar no GraphRAG (sistema principal)
                self.graph.register_pattern(reaction, pattern, category, agent_name)
                
                # Atualizar estat√≠sticas
                self.reflection_stats["agents_processed"].add(agent_name)
                if pattern not in self.reflection_stats["patterns_identified"]:
                    self.reflection_stats["patterns_identified"][pattern] = 0
                self.reflection_stats["patterns_identified"][pattern] += 1
                
                # Exibir feedback
                print(f"üß† {agent_name} ‚Üí padr√£o: '{pattern}' (categoria: {category})")
                
                # ‚ö° CONDICIONAL: Apenas adicionar ao log MD se habilitado
                if self.enable_md_logging:
                    log_lines.append(f"- **{agent_name}** ‚Üí Padr√£o: _{pattern}_ (Categoria: _{category}_)")
                
                processed_patterns.append({
                    "agent": agent_name,
                    "pattern": pattern,
                    "category": category,
                    "timestamp": timestamp
                })
                
            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao processar agente {agent.__class__.__name__}: {e}")
                continue
        
        # ‚ö° CONDICIONAL: Salvar em MD apenas se habilitado
        if self.enable_md_logging and log_lines:
            log_lines.append("\n")
            self.append_to_log(log_lines)
        
        # üìä Exibir estat√≠sticas de reflex√£o
        self._display_reflection_summary(processed_patterns)
        
        print("‚úÖ Reflex√£o simb√≥lica registrada com sucesso.\n")
        
        return processed_patterns

    def _display_reflection_summary(self, patterns):
        """Exibe resumo da reflex√£o atual"""
        if not patterns:
            print("‚ö†Ô∏è Nenhum padr√£o processado neste ciclo")
            return
        
        # Contar padr√µes √∫nicos
        unique_patterns = set(p["pattern"] for p in patterns)
        unique_categories = set(p["category"] for p in patterns)
        
        print(f"üìä Resumo da reflex√£o:")
        print(f"   ‚Ä¢ Agentes processados: {len(patterns)}")
        print(f"   ‚Ä¢ Padr√µes √∫nicos: {len(unique_patterns)}")
        print(f"   ‚Ä¢ Categorias: {', '.join(unique_categories)}")
        print(f"   ‚Ä¢ Total de ciclos: {self.reflection_stats['total_cycles']}")
        
        # Mostrar padr√£o mais comum
        if self.reflection_stats["patterns_identified"]:
            most_common = max(self.reflection_stats["patterns_identified"].items(), 
                            key=lambda x: x[1])
            print(f"   ‚Ä¢ Padr√£o mais frequente: {most_common[0]} ({most_common[1]}x)")

    def identify_pattern(self, text):
        """
        Identifica padr√£o no texto de sa√≠da do agente
        MANTIDO: L√≥gica original preservada
        """
        if not text or not isinstance(text, str):
            return "Execu√ß√£o padr√£o"
        
        text = text.lower()
        
        # Padr√µes de erro/falha
        if any(keyword in text for keyword in ["erro", "falha", "exception", "error"]):
            return "Comportamento an√¥malo"
        
        # Padr√µes espec√≠ficos de dom√≠nio
        elif any(keyword in text for keyword in ["documenta√ß√£o", "doc", "readme"]):
            return "Atualiza√ß√£o documental"
        elif any(keyword in text for keyword in ["teste", "test", "assert", "pytest"]):
            return "Cobertura de teste"
        elif any(keyword in text for keyword in ["login", "auth", "fun√ß√£o", "def "]):
            return "Implementa√ß√£o funcional"
        elif any(keyword in text for keyword in ["refactor", "otimiz", "melhori"]):
            return "Otimiza√ß√£o de c√≥digo"
        else:
            return "Execu√ß√£o padr√£o"

    def categorize_pattern(self, pattern):
        """
        Categoriza padr√£o identificado
        MANTIDO: L√≥gica original preservada + novas categorias
        """
        mapping = {
            "Comportamento an√¥malo": "Falha",
            "Atualiza√ß√£o documental": "Documenta√ß√£o",
            "Cobertura de teste": "Testes",
            "Implementa√ß√£o funcional": "Funcionalidade",
            "Otimiza√ß√£o de c√≥digo": "Otimiza√ß√£o",
            "Execu√ß√£o padr√£o": "Opera√ß√£o"
        }
        return mapping.get(pattern, "Outro")

    def append_to_log(self, lines):
        """
        ‚ö° OTIMIZADO: Apenas executa se logging MD estiver habilitado
        """
        if not self.enable_md_logging or not self.log_path:
            return  # Sair silenciosamente se MD logging desabilitado
        
        try:
            with open(self.log_path, "a", encoding="utf-8") as log_file:
                log_file.write("\n".join(lines) + "\n")
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao escrever log MD: {e}")

    def get_reflection_stats(self):
        """
        NOVO: Retorna estat√≠sticas de reflex√£o do GraphRAG
        """
        stats = {
            "local_stats": self.reflection_stats,
            "graphrag_enabled": not self.using_mock,
            "md_logging_enabled": self.enable_md_logging
        }
        
        # Adicionar estat√≠sticas do GraphRAG se dispon√≠vel
        if not self.using_mock:
            try:
                graphrag_stats = self.graph.get_categories_and_counts()
                stats["graphrag_categories"] = graphrag_stats
            except Exception as e:
                stats["graphrag_error"] = str(e)
        
        return stats

    def export_patterns_summary(self):
        """
        NOVO: Exporta resumo de padr√µes do GraphRAG
        """
        if self.using_mock:
            return {
                "source": "mock",
                "patterns": list(self.reflection_stats["patterns_identified"].keys()),
                "total_cycles": self.reflection_stats["total_cycles"]
            }
        
        try:
            # Obter padr√µes do GraphRAG
            patterns = self.graph.get_patterns_by_agent("all")  # Se m√©todo existir
            categories = self.graph.get_categories_and_counts()
            
            return {
                "source": "graphrag",
                "patterns": patterns if patterns else [],
                "categories": categories,
                "agents_processed": list(self.reflection_stats["agents_processed"]),
                "total_cycles": self.reflection_stats["total_cycles"],
                "timestamp": datetime.now().isoformat()
            }
        except Exception as e:
            return {
                "source": "error",
                "error": str(e),
                "fallback_stats": self.reflection_stats
            }

    def cleanup_old_data(self, max_age_days=30):
        """
        NOVO: Limpeza de dados antigos para economizar mem√≥ria
        """
        if self.using_mock:
            print("üßπ Limpeza n√£o necess√°ria (modo mock)")
            return
        
        try:
            # Implementar limpeza no GraphRAG se necess√°rio
            print(f"üßπ Iniciando limpeza de dados > {max_age_days} dias")
            
            # Para implementa√ß√£o futura - limpeza baseada em timestamp
            # self.graph.cleanup_old_patterns(max_age_days)
            
            print("‚úÖ Limpeza conclu√≠da")
        except Exception as e:
            print(f"‚ö†Ô∏è Erro na limpeza: {e}")

    def close(self):
        """
        Fecha conex√µes do GraphRAG
        """
        if hasattr(self.graph, 'close'):
            self.graph.close()
        
        # Exibir estat√≠sticas finais
        if LEGACY_FEATURES.get("verbose_logging", False):
            print(f"\nüìä Estat√≠sticas finais do ReflectionAgent:")
            print(f"   ‚Ä¢ Total de ciclos: {self.reflection_stats['total_cycles']}")
            print(f"   ‚Ä¢ Agentes processados: {len(self.reflection_stats['agents_processed'])}")
            print(f"   ‚Ä¢ Padr√µes identificados: {len(self.reflection_stats['patterns_identified'])}")
            print(f"   ‚Ä¢ GraphRAG: {'‚úÖ' if not self.using_mock else '‚ùå Mock'}")
            print(f"   ‚Ä¢ MD Logging: {'‚úÖ' if self.enable_md_logging else '‚ùå Desabilitado'}")


# ‚ö° FUN√á√ÉO UTILIT√ÅRIA: Migra√ß√£o de dados MD para GraphRAG (se necess√°rio)
def migrate_md_to_graphrag(md_file_path="reflection/analysis_history.md"):
    """
    Utilit√°rio para migrar dados do analysis_history.md para GraphRAG
    """
    print(f"üîÑ Iniciando migra√ß√£o de {md_file_path} para GraphRAG...")
    
    if not os.path.exists(md_file_path):
        print(f"‚ö†Ô∏è Arquivo {md_file_path} n√£o encontrado")
        return False
    
    try:
        # Criar inst√¢ncia do ReflectionAgent para acessar GraphRAG
        agent = ReflectionAgent()
        
        # Ler arquivo MD e extrair dados (implementa√ß√£o simples)
        with open(md_file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Processar linha por linha (implementa√ß√£o b√°sica)
        lines = content.split('\n')
        migrated_count = 0
        
        for line in lines:
            if line.startswith('- **') and '**' in line:
                # Extrair dados da linha: - **AgentName** ‚Üí Padr√£o: _pattern_ (Categoria: _category_)
                try:
                    parts = line.split('‚Üí')
                    if len(parts) >= 2:
                        agent_part = parts[0].replace('- **', '').replace('**', '').strip()
                        pattern_part = parts[1]
                        
                        # Extrair padr√£o e categoria com regex simples
                        import re
                        pattern_match = re.search(r'Padr√£o: _([^_]+)_', pattern_part)
                        category_match = re.search(r'Categoria: _([^_]+)_', pattern_part)
                        
                        if pattern_match and category_match:
                            pattern = pattern_match.group(1)
                            category = category_match.group(1)
                            
                            # Registrar no GraphRAG
                            agent.graph.register_pattern("migrated_data", pattern, category, agent_part)
                            migrated_count += 1
                            
                except Exception as e:
                    print(f"‚ö†Ô∏è Erro ao processar linha: {line[:50]}... - {e}")
                    continue
        
        agent.close()
        
        print(f"‚úÖ Migra√ß√£o conclu√≠da: {migrated_count} entradas migradas")
        
        # Opcional: Fazer backup do arquivo MD
        backup_path = f"{md_file_path}.backup"
        import shutil
        shutil.copy2(md_file_path, backup_path)
        print(f"üíæ Backup criado: {backup_path}")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Erro na migra√ß√£o: {e}")
        return False


# üß™ Teste da funcionalidade
if __name__ == "__main__":
    print("üß™ Testando ReflectionAgent otimizado...")
    
    # Criar agente de teste
    agent = ReflectionAgent()
    
    # Simular agentes mock
    class MockAgent:
        def __init__(self, name, output):
            self.__class__.__name__ = name
            self.latest_output = output
    
    mock_agents = [
        MockAgent("CodeAgent", "def login(): return True"),
        MockAgent("TestAgent", "test completed successfully"),
        MockAgent("DocumentationAgent", "documentation updated")
    ]
    
    # Executar reflex√£o
    patterns = agent.reflect_on_tasks(mock_agents)
    
    # Exibir estat√≠sticas
    stats = agent.get_reflection_stats()
    print(f"\nüìä Estat√≠sticas: {stats}")
    
    # Exportar resumo
    summary = agent.export_patterns_summary()
    print(f"\nüìã Resumo: {summary}")
    
    agent.close()
    print("\n‚úÖ Teste conclu√≠do!")